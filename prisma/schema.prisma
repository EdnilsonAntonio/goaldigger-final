generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

enum Plan {
  free
  plus
  pro
}

enum SubscriptionPeriod {
  monthly
  yearly
}

model User {
  id         String  @id @default(cuid()) @map("_id")
  email      String  @unique
  name       String?
  image      String?
  plan       Plan    @default(free)
  customerId String? // Stripe customer ID, this will be important when we need to delete the subscription

  tasks        Task[]           // relação 1:N (um usuário pode ter várias tarefas)
  tasksLists   TasksList[]      // <- acesso a todas as listas desse usuário
  goals        Goal[]           // relação 1:N (um usuário pode ter vários goals)
  pomotasks    PomoTask[]       // relação 1:N (um usuário pode ter vários pomotasks)
  transactions Transaction[]    // relação 1:N (um usuário pode ter várias transações)
  bugReports   BugReport[]      // relação 1:N (um usuário pode ter vários bug reports)
  supportRequests SupportRequest[] // relação 1:N (um usuário pode ter vários support requests)
  reviews      Review[]         // relação 1:N (um usuário pode ter várias reviews)

  Subscription Subscription?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Subscription {
  id     String             @id @default(cuid()) @map("_id")
  userId String             @unique
  plan   Plan
  period SubscriptionPeriod

  startDate DateTime @default(now())
  endDate   DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  User User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum TaskState {
  done
  undone
}

enum RepeatUnit {
  day
  week
  month
  year
}

enum DayOfWeek {
  monday
  tuesday
  wednesday
  thursday
  friday
  saturday
  sunday
}

enum TaskPriority {
  high
  medium
  low
  none
}

enum GoalState {
  inProgress
  achieved
}

model Task {
  id             String       @id @default(cuid()) @map("_id")
  userId         String
  title          String
  description    String?
  state          TaskState    @default(undone)

  tasksListId    String
  tasksList      TasksList   @relation(fields: [tasksListId], references: [id], onDelete: Cascade)

  order          Int          @default(0)

  repeat         Boolean      @default(false)
  repeatInterval Int?         
  repeatUnit     RepeatUnit?  
  repeatDays     DayOfWeek[]  
  occurences     Int?         
  resetDay       DateTime?

  priority       TaskPriority @default(none)

  startDate      DateTime?
  endDate        DateTime?

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model TasksList {
  id        String   @id @default(cuid()) @map("_id")
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  title     String
  order     Int      @default(0)
  tasks     Task[]

  completion Float   @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PomoTask {
  id            String   @id @default(uuid()) @map("_id")
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  title         String
  notes         String?
  estPomodoros  Int          @default(1)
  state         TaskState    @default(undone)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

model Goal {
  id          String    @id @default(cuid()) @map("_id")
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  title       String
  description String?
  state       GoalState @default(inProgress)
  
  // Para goals numerados
  isNumeric   Boolean   @default(false)
  target      Float?    // Valor alvo (ex: 10000 para 10k dólares)
  current     Float     @default(0) // Progresso atual
  unit        String?   // Unidade de medição (ex: "dollars", "books")
  
  // Para todos os goals
  deadline    DateTime?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum TransactionType {
  income
  expense
}

model Transaction {
  id          String          @id @default(cuid()) @map("_id")
  userId      String
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  title       String
  amount      Float           
  category    String          @default("General")
  type        TransactionType
  date        DateTime
  description String?         

  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([userId])           // índice para melhorar performance de queries por usuário
  @@index([date])             // índice para filtrar por data (útil para relatórios mensais)
  @@index([type])             // índice para filtrar por tipo (income/expense)
}

enum BugReportStatus {
  pending
  inProgress
  resolved
  closed
}

model BugReport {
  id          String           @id @default(cuid()) @map("_id")
  userId      String?          // Opcional, pois usuários não autenticados também podem reportar
  user        User?            @relation(fields: [userId], references: [id], onDelete: SetNull)

  title       String
  description String
  email       String?          // Email do usuário (obrigatório se não autenticado)
  status      BugReportStatus  @default(pending)
  browserInfo String?          // Informações do navegador
  userAgent   String?          // User agent string
  url         String?          // URL onde o bug ocorreu

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

enum SupportRequestCategory {
  billing
  technical
  account
  feature
  general
  other
}

enum SupportRequestStatus {
  pending
  inProgress
  resolved
  closed
}

model SupportRequest {
  id          String                  @id @default(cuid()) @map("_id")
  userId      String?                 // Opcional, pois usuários não autenticados também podem solicitar suporte
  user        User?                   @relation(fields: [userId], references: [id], onDelete: SetNull)

  title       String
  description String
  category    SupportRequestCategory
  email       String?                 // Email do usuário (obrigatório se não autenticado)
  status      SupportRequestStatus     @default(pending)

  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @updatedAt

  @@index([userId])
  @@index([status])
  @@index([category])
  @@index([createdAt])
}

model Review {
  id          String   @id @default(cuid()) @map("_id")
  userId      String?  // Opcional, mas recomendado para evitar reviews duplicadas
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  rating      Int      // Rating de 1 a 5 estrelas
  comment     String?  // Comentário opcional
  name        String?  // Nome do revisor (se não autenticado)
  email       String?  // Email do revisor (se não autenticado)
  approved    Boolean  @default(false) // Para moderar reviews antes de exibir

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([rating])
  @@index([approved])
  @@index([createdAt])
}